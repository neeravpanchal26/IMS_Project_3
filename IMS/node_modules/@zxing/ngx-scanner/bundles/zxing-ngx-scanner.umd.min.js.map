{
  "version": 3,
  "file": "zxing-ngx-scanner.umd.min.js",
  "sources": [
    "ng://@zxing/ngx-scanner/node_modules/tslib/tslib.es6.js",
    "ng://@zxing/ngx-scanner/out/app/modules/zxing-scanner/browser-code-reader.ts",
    "ng://@zxing/ngx-scanner/out/app/modules/zxing-scanner/browser-multi-format-reader.ts",
    "ng://@zxing/ngx-scanner/out/app/modules/zxing-scanner/browser-qr-code-reader.ts",
    "ng://@zxing/ngx-scanner/out/app/modules/zxing-scanner/zxing-scanner.component.ts",
    "ng://@zxing/ngx-scanner/out/app/modules/zxing-scanner/zxing-scanner.module.ts"
  ],
  "sourcesContent": [
    "/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n",
    "/// <reference path=\"./image-capture.d.ts\" />\r\n\r\nimport {\r\n    BinaryBitmap,\r\n    ChecksumException,\r\n    Exception,\r\n    FormatException,\r\n    HTMLCanvasElementLuminanceSource,\r\n    HybridBinarizer,\r\n    NotFoundException,\r\n    Reader,\r\n    Result,\r\n} from '@zxing/library';\r\n\r\nimport {\r\n    BehaviorSubject,\r\n    Observable,\r\n    Subscriber,\r\n    Subscription\r\n} from 'rxjs';\r\n\r\nimport { catchError } from 'rxjs/operators';\r\n\r\n/**\r\n * Based on zxing-typescript BrowserCodeReader\r\n */\r\nexport class BrowserCodeReader {\r\n\r\n    /**\r\n     * The HTML video element, used to display the camera stream.\r\n     */\r\n    private videoElement: HTMLVideoElement;\r\n    /**\r\n     * Should contain the current registered listener for video play-ended,\r\n     * used to unregister that listener when needed.\r\n     */\r\n    private videoPlayEndedEventListener: EventListener;\r\n    /**\r\n     * Should contain the current registered listener for video playing,\r\n     * used to unregister that listener when needed.\r\n     */\r\n    private videoPlayingEventListener: EventListener;\r\n    /**\r\n     * Should contain the current registered listener for video loaded-metadata,\r\n     * used to unregister that listener when needed.\r\n     */\r\n    private videoLoadedMetadataEventListener: EventListener;\r\n\r\n    /**\r\n     * The HTML image element, used as a fallback for the video element when decoding.\r\n     */\r\n    private imageElement: HTMLImageElement;\r\n    /**\r\n     * Should contain the current registered listener for image loading,\r\n     * used to unregister that listener when needed.\r\n     */\r\n    private imageLoadedEventListener: EventListener;\r\n\r\n    /**\r\n     * The HTML canvas element, used to draw the video or image's frame for decoding.\r\n     */\r\n    private canvasElement: HTMLCanvasElement;\r\n    /**\r\n     * The HTML canvas element context.\r\n     */\r\n    private canvasElementContext: CanvasRenderingContext2D;\r\n\r\n    /**\r\n     * Used to control the decoding stream when it's open.\r\n     */\r\n    private decodingStream: Subscription;\r\n\r\n    /**\r\n     * The stream output from camera.\r\n     */\r\n    private stream: MediaStream;\r\n    /**\r\n     * The track from camera.\r\n     */\r\n    private track: MediaStreamTrack;\r\n    /**\r\n     * Shows if torch is available on the camera.\r\n     */\r\n    private torchCompatible = new BehaviorSubject<boolean>(false);\r\n\r\n    /**\r\n     * The device id of the current media device.\r\n     */\r\n    private deviceId: string;\r\n\r\n    /**\r\n     * Constructor for dependency injection.\r\n     *\r\n     * @param reader The barcode reader to be used to decode the stream.\r\n     * @param timeBetweenScans The scan throttling in milliseconds.\r\n     */\r\n    public constructor(protected readonly reader: Reader, private timeBetweenScans: number = 500) { }\r\n\r\n    /**\r\n     * Starts the decoding from the current or a new video element.\r\n     *\r\n     * @param callbackFn The callback to be executed after every scan attempt\r\n     * @param deviceId The device's to be used Id\r\n     * @param videoElement A new video element\r\n     *\r\n     * @todo Return Promise<Result>\r\n     */\r\n    public async decodeFromInputVideoDevice(\r\n        callbackFn?: (result: Result) => any,\r\n        deviceId?: string,\r\n        videoElement?: HTMLVideoElement\r\n    ): Promise<void> {\r\n\r\n        this.reset();\r\n\r\n        this.prepareVideoElement(videoElement);\r\n\r\n        // Keeps the deviceId between scanner resets.\r\n        if (typeof deviceId !== 'undefined') {\r\n            this.deviceId = deviceId;\r\n        }\r\n\r\n        const video = typeof deviceId === 'undefined'\r\n            ? { facingMode: { exact: 'environment' } }\r\n            : { deviceId: { exact: deviceId } };\r\n\r\n        const constraints: MediaStreamConstraints = {\r\n            audio: false,\r\n            video\r\n        };\r\n\r\n        if (typeof navigator === 'undefined') {\r\n            return;\r\n        }\r\n\r\n        try {\r\n            const stream = await navigator\r\n                .mediaDevices\r\n                .getUserMedia(constraints);\r\n\r\n            this.startDecodeFromStream(stream, callbackFn);\r\n\r\n        } catch (err) {\r\n            /* handle the error, or not */\r\n            console.error(err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the new stream and request a new decoding-with-delay.\r\n     *\r\n     * @param stream The stream to be shown in the video element.\r\n     * @param callbackFn A callback for the decode method.\r\n     *\r\n     * @todo Return Promise<Result>\r\n     */\r\n    private startDecodeFromStream(stream: MediaStream, callbackFn?: (result: Result) => any): void {\r\n        this.stream = stream;\r\n        this.checkTorchCompatibility(this.stream);\r\n        this.bindVideoSrc(this.videoElement, this.stream);\r\n        this.bindEvents(this.videoElement, callbackFn);\r\n    }\r\n\r\n    /**\r\n     * Defines what the videoElement src will be.\r\n     *\r\n     * @param videoElement\r\n     * @param stream\r\n     */\r\n    public bindVideoSrc(videoElement: HTMLVideoElement, stream: MediaStream): void {\r\n        // Older browsers may not have `srcObject`\r\n        try {\r\n            // @NOTE Throws Exception if interrupted by a new loaded request\r\n            videoElement.srcObject = stream;\r\n        } catch (err) {\r\n            // @NOTE Avoid using this in new browsers, as it is going away.\r\n            videoElement.src = window.URL.createObjectURL(stream);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unbinds a HTML video src property.\r\n     *\r\n     * @param videoElement\r\n     */\r\n    public unbindVideoSrc(videoElement: HTMLVideoElement): void {\r\n        try {\r\n            videoElement.srcObject = null;\r\n        } catch (err) {\r\n            videoElement.src = '';\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds listeners and callbacks to the videoElement.\r\n     *\r\n     * @param videoElement\r\n     * @param callbackFn\r\n     */\r\n    private bindEvents(videoElement: HTMLVideoElement, callbackFn?: (result: Result) => any): void {\r\n\r\n        if (typeof callbackFn !== 'undefined') {\r\n            this.videoPlayingEventListener = () => this.decodingStream = this.decodeWithDelay(this.timeBetweenScans)\r\n                .pipe(catchError((e, x) => this.handleDecodeStreamError(e, x)))\r\n                .subscribe((x: Result) => callbackFn(x));\r\n        }\r\n\r\n        videoElement.addEventListener('playing', this.videoPlayingEventListener);\r\n\r\n        this.videoLoadedMetadataEventListener = () => videoElement.play();\r\n\r\n        videoElement.addEventListener('loadedmetadata', this.videoLoadedMetadataEventListener);\r\n    }\r\n\r\n    /**\r\n     * Checks if the stream supports torch control.\r\n     *\r\n     * @param stream The media stream used to check.\r\n     */\r\n    private async checkTorchCompatibility(stream: MediaStream): Promise<void> {\r\n        try {\r\n            this.track = stream.getVideoTracks()[0];\r\n            const imageCapture = new ImageCapture(this.track);\r\n            const capabilities = await imageCapture.getPhotoCapabilities();\r\n            const compatible = !!capabilities.torch || ('fillLightMode' in capabilities && capabilities.fillLightMode.length !== 0);\r\n            this.torchCompatible.next(compatible);\r\n        } catch (err) {\r\n            this.torchCompatible.next(false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enables and disables the device torch.\r\n     */\r\n    public setTorch(on: boolean): void {\r\n        if (!this.torchCompatible.value) {\r\n            return;\r\n        }\r\n        if (on) {\r\n            this.track.applyConstraints({\r\n                advanced: [<any>{ torch: true }]\r\n            });\r\n        } else {\r\n            this.restart();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Observable that says if there's a torch available for the current device.\r\n     */\r\n    public get torchAvailable(): Observable<boolean> {\r\n        return this.torchCompatible.asObservable();\r\n    }\r\n\r\n    /**\r\n     * Sets a HTMLVideoElement for scanning or creates a new one.\r\n     *\r\n     * @param videoElement The HTMLVideoElement to be set.\r\n     */\r\n    private prepareVideoElement(videoElement?: HTMLVideoElement): void {\r\n\r\n        if (!videoElement && typeof document !== 'undefined') {\r\n            videoElement = document.createElement('video');\r\n            videoElement.width = 200;\r\n            videoElement.height = 200;\r\n        }\r\n\r\n        this.videoElement = videoElement;\r\n    }\r\n\r\n    /**\r\n     * Opens a decoding stream.\r\n     */\r\n    private decodeWithDelay(delay: number = 500): Observable<Result> {\r\n        // The decoding stream.\r\n        return Observable.create((observer: Subscriber<Result>) => {\r\n            // Creates on Subscribe.\r\n            const intervalId = setInterval(() => {\r\n                try {\r\n                    observer.next(this.decode());\r\n                } catch (err) {\r\n                    observer.error(err);\r\n                }\r\n            }, delay);\r\n            // Destroys on Unsubscribe.\r\n            return () => clearInterval(intervalId);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the BinaryBitmap for ya! (and decodes it)\r\n     */\r\n    private decode(): Result {\r\n\r\n        // get binary bitmap for decode function\r\n        const binaryBitmap = this.createBinaryBitmap(this.videoElement || this.imageElement);\r\n\r\n        return this.decodeBitmap(binaryBitmap);\r\n    }\r\n\r\n    /**\r\n     * Call the encapsulated readers decode\r\n     */\r\n    protected decodeBitmap(binaryBitmap: BinaryBitmap): Result {\r\n        return this.reader.decode(binaryBitmap);\r\n    }\r\n\r\n    /**\r\n     * Administra um erro gerado durante o decode stream.\r\n     */\r\n    private handleDecodeStreamError(err: Exception, caught: Observable<Result>): Observable<Result> {\r\n\r\n        if (\r\n            // scan Failure - found nothing, no error\r\n            err instanceof NotFoundException ||\r\n            // scan Error - found the QR but got error on decoding\r\n            err instanceof ChecksumException ||\r\n            err instanceof FormatException\r\n        ) {\r\n            return caught;\r\n        }\r\n\r\n        throw err;\r\n    }\r\n\r\n    /**\r\n     * Creates a binaryBitmap based in some image source.\r\n     *\r\n     * @param mediaElement HTML element containing drawable image source.\r\n     */\r\n    private createBinaryBitmap(mediaElement: HTMLVideoElement | HTMLImageElement): BinaryBitmap {\r\n\r\n        if (undefined === this.canvasElementContext) {\r\n            this.prepareCaptureCanvas();\r\n        }\r\n\r\n        this.canvasElementContext.drawImage(mediaElement, 0, 0);\r\n\r\n        const luminanceSource = new HTMLCanvasElementLuminanceSource(this.canvasElement);\r\n        const hybridBinarizer = new HybridBinarizer(luminanceSource);\r\n\r\n        return new BinaryBitmap(hybridBinarizer);\r\n    }\r\n\r\n    /**\r\n     * ðŸ–Œ Prepares the canvas for capture and scan frames.\r\n     */\r\n    private prepareCaptureCanvas(): void {\r\n\r\n        if (typeof document === 'undefined') {\r\n\r\n            this.canvasElement = undefined;\r\n            this.canvasElementContext = undefined;\r\n\r\n            return;\r\n        }\r\n\r\n        const canvasElement = document.createElement('canvas');\r\n\r\n        let width: number;\r\n        let height: number;\r\n\r\n        if (typeof this.videoElement !== 'undefined') {\r\n            width = this.videoElement.videoWidth;\r\n            height = this.videoElement.videoHeight;\r\n        }\r\n\r\n        if (typeof this.imageElement !== 'undefined') {\r\n            width = this.imageElement.naturalWidth || this.imageElement.width;\r\n            height = this.imageElement.naturalHeight || this.imageElement.height;\r\n        }\r\n\r\n        canvasElement.style.width = width + 'px';\r\n        canvasElement.style.height = height + 'px';\r\n        canvasElement.width = width;\r\n        canvasElement.height = height;\r\n\r\n        this.canvasElement = canvasElement;\r\n        this.canvasElementContext = canvasElement.getContext('2d');\r\n    }\r\n\r\n    /**\r\n     * Stops the continuous scan and cleans the stream.\r\n     */\r\n    private stop(): void {\r\n\r\n        if (this.decodingStream) {\r\n            this.decodingStream.unsubscribe();\r\n        }\r\n\r\n        if (this.stream) {\r\n            this.stream.getVideoTracks().forEach(t => t.stop());\r\n            this.stream = undefined;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Resets the scanner and it's configurations.\r\n     */\r\n    public reset(): void {\r\n\r\n        // stops the camera, preview and scan ðŸ”´\r\n\r\n        this.stop();\r\n\r\n        if (this.videoElement) {\r\n\r\n            // first gives freedon to the element ðŸ•Š\r\n\r\n            if (typeof this.videoPlayEndedEventListener !== 'undefined') {\r\n                this.videoElement.removeEventListener('ended', this.videoPlayEndedEventListener);\r\n            }\r\n\r\n            if (typeof this.videoPlayingEventListener !== 'undefined') {\r\n                this.videoElement.removeEventListener('playing', this.videoPlayingEventListener);\r\n            }\r\n\r\n            if (typeof this.videoLoadedMetadataEventListener !== 'undefined') {\r\n                this.videoElement.removeEventListener('loadedmetadata', this.videoLoadedMetadataEventListener);\r\n            }\r\n\r\n            // then forgets about that element ðŸ˜¢\r\n\r\n            this.unbindVideoSrc(this.videoElement);\r\n\r\n            this.videoElement.removeAttribute('src');\r\n            this.videoElement = undefined;\r\n        }\r\n\r\n        if (this.imageElement) {\r\n\r\n            // first gives freedon to the element ðŸ•Š\r\n\r\n            if (undefined !== this.videoPlayEndedEventListener) {\r\n                this.imageElement.removeEventListener('load', this.imageLoadedEventListener);\r\n            }\r\n\r\n            // then forgets about that element ðŸ˜¢\r\n\r\n            this.imageElement.src = undefined;\r\n            this.imageElement.removeAttribute('src');\r\n            this.imageElement = undefined;\r\n        }\r\n\r\n        // cleans canvas references ðŸ–Œ\r\n\r\n        this.canvasElementContext = undefined;\r\n        this.canvasElement = undefined;\r\n    }\r\n\r\n    /**\r\n     * Restarts the scanner.\r\n     */\r\n    private restart(): void {\r\n        // reset\r\n        // start\r\n        this.decodeFromInputVideoDevice(undefined, this.deviceId, this.videoElement);\r\n    }\r\n}\r\n",
    "import { MultiFormatReader, DecodeHintType, BinaryBitmap, Result } from '@zxing/library';\r\n\r\nimport { BrowserCodeReader } from './browser-code-reader';\r\n\r\nexport class BrowserMultiFormatReader extends BrowserCodeReader {\r\n\r\n    protected readonly reader: MultiFormatReader;\r\n\r\n    public constructor(\r\n        hints: Map<DecodeHintType, any> = null,\r\n        timeBetweenScansMillis: number = 500\r\n    ) {\r\n        const reader = new MultiFormatReader();\r\n        reader.setHints(hints);\r\n        super(reader, timeBetweenScansMillis);\r\n    }\r\n\r\n    /**\r\n     * Overwrite decodeBitmap to call decodeWithState, which will pay\r\n     * attention to the hints set in the constructor function\r\n     */\r\n    protected decodeBitmap(binaryBitmap: BinaryBitmap): Result {\r\n        return this.reader.decodeWithState(binaryBitmap);\r\n    }\r\n}\r\n",
    "import { QRCodeReader } from '@zxing/library';\r\n\r\nimport { BrowserCodeReader } from './browser-code-reader';\r\n\r\nexport class BrowserQRCodeReader extends BrowserCodeReader {\r\n    public constructor(timeBetweenScansMillis: number = 500) {\r\n        super(new QRCodeReader(), timeBetweenScansMillis);\r\n    }\r\n}\r\n",
    "import {\r\n    AfterViewInit,\r\n    ChangeDetectionStrategy,\r\n    Component,\r\n    ElementRef,\r\n    EventEmitter,\r\n    Input,\r\n    OnChanges,\r\n    OnDestroy,\r\n    Output,\r\n    SimpleChanges,\r\n    ViewChild\r\n} from '@angular/core';\r\n\r\nimport { Result, DecodeHintType, BarcodeFormat } from '@zxing/library';\r\n\r\nimport { BrowserMultiFormatReader } from './browser-multi-format-reader';\r\nimport { BrowserQRCodeReader } from './browser-qr-code-reader';\r\nimport { BrowserCodeReader } from './browser-code-reader';\r\n\r\n@Component({\r\n    // tslint:disable-next-line:component-selector\r\n    selector: 'zxing-scanner',\r\n    template: `<video #preview [style.object-fit]=\"previewFitMode\">\r\n    <p>\r\n        Your browser does not support this feature, please try to upgrade it.\r\n    </p>\r\n    <p>\r\n        Seu navegador nÃ£o suporta este recurso, por favor tente atualizÃ¡-lo.\r\n    </p>\r\n</video>\r\n`,\r\n    styles: [`:host{display:block}video{width:100%;height:auto;-o-object-fit:contain;object-fit:contain}`],\r\n    changeDetection: ChangeDetectionStrategy.OnPush\r\n})\r\nexport class ZXingScannerComponent implements AfterViewInit, OnDestroy, OnChanges {\r\n\r\n    /**\r\n     * The ZXing code reader.\r\n     */\r\n    private codeReader: BrowserCodeReader;\r\n\r\n    /**\r\n     * Has `navigator` access.\r\n     */\r\n    private hasNavigator: boolean;\r\n\r\n\r\n    /**\r\n     * Says if some native API is supported.\r\n     */\r\n    private isMediaDevicesSuported: boolean;\r\n\r\n    /**\r\n     * Says if some native API is supported.\r\n     */\r\n    private isEnumerateDevicesSuported: boolean;\r\n\r\n    /**\r\n     * List of enable video-input devices.\r\n     */\r\n    private videoInputDevices: MediaDeviceInfo[];\r\n    /**\r\n     * The current device used to scan things.\r\n     */\r\n    private videoInputDevice: MediaDeviceInfo;\r\n\r\n    /**\r\n     * If the user-agent allowed the use of the camera or not.\r\n     */\r\n    private hasPermission: boolean;\r\n\r\n    /**\r\n     * If any media device were found.\r\n     */\r\n    private set _hasDevices(hasDevice: boolean) {\r\n        this.hasDevices.next(hasDevice);\r\n    }\r\n\r\n    /**\r\n     * Reference to the preview element, should be the `video` tag.\r\n     */\r\n    @ViewChild('preview')\r\n    previewElemRef: ElementRef;\r\n\r\n    /**\r\n     * Barcode formats to scan\r\n     */\r\n    private _formats: BarcodeFormat[] = [BarcodeFormat.QR_CODE];\r\n\r\n    get formats() {\r\n        return this._formats;\r\n    }\r\n\r\n    @Input()\r\n    set formats(formatsInput: BarcodeFormat[]) {\r\n        // formats may be set from html template as BarcodeFormat or string array\r\n        const formats = <(string | BarcodeFormat)[]>formatsInput;\r\n        this._formats = formats.map(f => (typeof f === 'string') ? BarcodeFormat[f.trim()] : f);\r\n    }\r\n\r\n    /**\r\n     * Allow start scan or not.\r\n     */\r\n    @Input()\r\n    scannerEnabled = true;\r\n\r\n    /**\r\n     * The device that should be used to scan things.\r\n     */\r\n    @Input()\r\n    device: MediaDeviceInfo;\r\n\r\n    /**\r\n     * Enable or disable autofocus of the camera (might have an impact on performance)\r\n     */\r\n    @Input()\r\n    autofocusEnabled = true;\r\n\r\n    /**\r\n     * How the preview element shoud be fit inside the :host container.\r\n     */\r\n    @Input()\r\n    previewFitMode: 'fill' | 'contain' | 'cover' | 'scale-down' | 'none' = 'cover';\r\n\r\n    /**\r\n     * Allow start scan or not.\r\n     */\r\n    @Input()\r\n    set torch(on: boolean) {\r\n        this.codeReader.setTorch(on);\r\n    }\r\n\r\n    /**\r\n     * Emitts events when the torch compatibility is changed.\r\n     */\r\n    @Output()\r\n    torchCompatible = new EventEmitter<boolean>();\r\n\r\n    /**\r\n     * Emitts events when a scan is successful performed, will inject the string value of the QR-code to the callback.\r\n     */\r\n    @Output()\r\n    scanSuccess = new EventEmitter<string>();\r\n\r\n    /**\r\n     * Emitts events when a scan fails without errors, usefull to know how much scan tries where made.\r\n     */\r\n    @Output()\r\n    scanFailure = new EventEmitter<void>();\r\n\r\n    /**\r\n     * Emitts events when a scan throws some error, will inject the error to the callback.\r\n     */\r\n    @Output()\r\n    scanError = new EventEmitter<Error>();\r\n\r\n    /**\r\n     * Emitts events when a scan is performed, will inject the Result value of the QR-code scan (if available) to the callback.\r\n     */\r\n    @Output()\r\n    scanComplete = new EventEmitter<Result>();\r\n\r\n    /**\r\n     * Emitts events when no cameras are found, will inject an exception (if available) to the callback.\r\n     */\r\n    @Output()\r\n    camerasFound = new EventEmitter<MediaDeviceInfo[]>();\r\n\r\n    /**\r\n     * Emitts events when no cameras are found, will inject an exception (if available) to the callback.\r\n     */\r\n    @Output()\r\n    camerasNotFound = new EventEmitter<any>();\r\n\r\n    /**\r\n     * Emitts events when the users answers for permission.\r\n     */\r\n    @Output()\r\n    permissionResponse = new EventEmitter<boolean>();\r\n\r\n    /**\r\n     * Emitts events when has devices status is update.\r\n     */\r\n    @Output()\r\n    hasDevices = new EventEmitter<boolean>();\r\n\r\n    /**\r\n     * Constructor to build the object and do some DI.\r\n     */\r\n    constructor() {\r\n        this.codeReader = new BrowserQRCodeReader();\r\n        this.hasNavigator = typeof navigator !== 'undefined';\r\n        this.isMediaDevicesSuported = this.hasNavigator && !!navigator.mediaDevices;\r\n        this.isEnumerateDevicesSuported = !!(this.isMediaDevicesSuported && navigator.mediaDevices.enumerateDevices);\r\n    }\r\n\r\n    /**\r\n     * Manages the bindinded property changes.\r\n     * @param changes\r\n     */\r\n    ngOnChanges(changes: SimpleChanges): void {\r\n\r\n        if (changes.scannerEnabled) {\r\n            if (!this.scannerEnabled) {\r\n                this.resetScan();\r\n            } else if (this.videoInputDevice) {\r\n                this.scan(this.videoInputDevice.deviceId);\r\n            }\r\n        }\r\n\r\n        if (changes.device) {\r\n            if (this.device) {\r\n                this.changeDevice(this.device);\r\n            } else {\r\n                console.warn('zxing-scanner', 'device', 'Unselected device.');\r\n                this.resetScan();\r\n            }\r\n        }\r\n\r\n        if (changes.formats !== undefined) {\r\n            this.setFormats(this.formats);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Executed after the view initialization.\r\n     */\r\n    async ngAfterViewInit(): Promise<void> {\r\n\r\n        // Chrome 63 fix\r\n        if (!this.previewElemRef) {\r\n            console.warn('zxing-scanner', 'Preview element not found!');\r\n            return;\r\n        }\r\n\r\n        // iOS 11 Fix\r\n        this.previewElemRef.nativeElement.setAttribute('autoplay', false);\r\n        this.previewElemRef.nativeElement.setAttribute('muted', true);\r\n        this.previewElemRef.nativeElement.setAttribute('playsinline', true);\r\n        this.previewElemRef.nativeElement.setAttribute('autofocus', this.autofocusEnabled);\r\n\r\n        // Asks for permission before enumerating devices so it can get all the device's info\r\n        const hasPermission = await this.askForPermission();\r\n\r\n        // gets and enumerates all video devices\r\n        this.enumarateVideoDevices().then((videoInputDevices: MediaDeviceInfo[]) => {\r\n\r\n            if (videoInputDevices && videoInputDevices.length > 0) {\r\n                this._hasDevices = true;\r\n                this.camerasFound.next(videoInputDevices);\r\n            } else {\r\n                this._hasDevices = false;\r\n                this.camerasNotFound.next();\r\n            }\r\n\r\n        });\r\n\r\n        // There's nothin' to do anymore if we don't have permissions.\r\n        if (hasPermission !== true) {\r\n            return;\r\n        }\r\n\r\n        this.startScan(this.videoInputDevice);\r\n\r\n        this.codeReader.torchAvailable.subscribe((value: boolean) => {\r\n            this.torchCompatible.emit(value);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Executes some actions before destroy the component.\r\n     */\r\n    ngOnDestroy(): void {\r\n        this.resetScan();\r\n    }\r\n\r\n    /**\r\n     * Changes the supported code formats.\r\n     * @param formats The formats to support.\r\n     */\r\n    setFormats(formats: BarcodeFormat[]): void {\r\n\r\n        this.formats = formats;\r\n\r\n        const hints = new Map<DecodeHintType, any>();\r\n        hints.set(DecodeHintType.POSSIBLE_FORMATS, formats);\r\n\r\n        this.codeReader = new BrowserMultiFormatReader(hints);\r\n\r\n        this.restartScan();\r\n    }\r\n\r\n    /**\r\n     * Properly changes the current target device.\r\n     *\r\n     * @param device\r\n     */\r\n    changeDevice(device: MediaDeviceInfo): void {\r\n        this.videoInputDevice = device;\r\n        this.startScan(device);\r\n    }\r\n\r\n    /**\r\n     * Properly changes the current target device using it's deviceId.\r\n     *\r\n     * @param deviceId\r\n     */\r\n    changeDeviceById(deviceId: string): void {\r\n        this.changeDevice(this.getDeviceById(deviceId));\r\n    }\r\n\r\n    /**\r\n     * Properly returns the target device using it's deviceId.\r\n     *\r\n     * @param deviceId\r\n     */\r\n    getDeviceById(deviceId: string): MediaDeviceInfo {\r\n        return this.videoInputDevices.find(device => device.deviceId === deviceId);\r\n    }\r\n\r\n    /**\r\n     * Sets the permission value and emmits the event.\r\n     */\r\n    private setPermission(hasPermission: boolean | null) {\r\n        this.hasPermission = hasPermission;\r\n        this.permissionResponse.next(hasPermission);\r\n        return this.permissionResponse;\r\n    }\r\n\r\n    /**\r\n     * Gets and registers all cammeras.\r\n     *\r\n     * @todo Return a Promise.\r\n     */\r\n    async askForPermission(): Promise<boolean> {\r\n\r\n        if (!this.hasNavigator) {\r\n            console.error('zxing-scanner', 'askForPermission', 'Can\\'t ask permission, navigator is not present.');\r\n            this.setPermission(null);\r\n            return this.hasPermission;\r\n        }\r\n\r\n        if (!this.isMediaDevicesSuported) {\r\n            console.error('zxing-scanner', 'askForPermission', 'Can\\'t get user media, this is not supported.');\r\n            this.setPermission(null);\r\n            return this.hasPermission;\r\n        }\r\n\r\n        let stream: MediaStream;\r\n\r\n        try {\r\n            // Will try to ask for permission\r\n            stream = await navigator.mediaDevices.getUserMedia({ audio: false, video: true });\r\n        } catch (err) {\r\n            return this.handlePermissionException(err);\r\n        }\r\n\r\n        let permission: boolean;\r\n\r\n        try {\r\n\r\n            // Start stream so Browser can display its permission-dialog\r\n            this.codeReader.bindVideoSrc(this.previewElemRef.nativeElement, stream);\r\n\r\n            // After permission was granted, we can stop it again\r\n            stream.getVideoTracks().forEach(track => {\r\n                track.stop();\r\n            });\r\n\r\n            // should stop the opened stream\r\n            this.codeReader.unbindVideoSrc(this.previewElemRef.nativeElement);\r\n\r\n            // if the scripts lives until here, that's only one mean:\r\n\r\n            // permission granted\r\n            permission = true;\r\n            this.setPermission(permission);\r\n\r\n        } catch (err) {\r\n\r\n            console.error('zxing-scanner', 'askForPermission', err);\r\n\r\n            // permission aborted\r\n            permission = null;\r\n            this.setPermission(permission);\r\n        }\r\n\r\n        // Returns the event emitter, so the dev can subscribe to it\r\n        return permission;\r\n    }\r\n\r\n    /**\r\n     * Returns the filtered permission.\r\n     *\r\n     * @param err\r\n     */\r\n    private handlePermissionException(err: DOMException): boolean {\r\n\r\n        // failed to grant permission to video input\r\n\r\n        console.warn('zxing-scanner', 'askForPermission', err);\r\n\r\n        let permission: boolean;\r\n\r\n        switch (err.name) {\r\n\r\n            // usually caused by not secure origins\r\n            case 'NotSupportedError':\r\n                console.warn('@zxing/ngx-scanner', err.message);\r\n                // could not claim\r\n                permission = null;\r\n                // can't check devices\r\n                this._hasDevices = null;\r\n                break;\r\n\r\n            // user denied permission\r\n            case 'NotAllowedError':\r\n                console.warn('@zxing/ngx-scanner', err.message);\r\n                // claimed and denied permission\r\n                permission = false;\r\n                // this means that input devices exists\r\n                this._hasDevices = true;\r\n                break;\r\n\r\n            // the device has no attached input devices\r\n            case 'NotFoundError':\r\n                console.warn('@zxing/ngx-scanner', err.message);\r\n                // no permissions claimed\r\n                permission = null;\r\n                // because there was no devices\r\n                this._hasDevices = false;\r\n                // tells the listener about the error\r\n                this.camerasNotFound.next(err);\r\n                break;\r\n\r\n            case 'NotReadableError':\r\n                console.warn('@zxing/ngx-scanner', 'Couldn\\'t read the device(s)\\'s stream, it\\'s probably in use by another app.');\r\n                // no permissions claimed\r\n                permission = null;\r\n                // there are devices, which I couldn't use\r\n                this._hasDevices = false;\r\n                // tells the listener about the error\r\n                this.camerasNotFound.next(err);\r\n                break;\r\n\r\n            default:\r\n                console.warn('@zxing/ngx-scanner', 'I was not able to define if I have permissions for camera or not.', err);\r\n                // unknown\r\n                permission = null;\r\n                // this._hasDevices = undefined;\r\n                break;\r\n\r\n        }\r\n\r\n        this.setPermission(permission);\r\n\r\n        // tells the listener about the error\r\n        this.permissionResponse.error(err);\r\n\r\n        return permission;\r\n    }\r\n\r\n    /**\r\n     * Starts the continuous scanning for the given device.\r\n     *\r\n     * @param deviceId The deviceId from the device.\r\n     */\r\n    scan(deviceId: string): void {\r\n        try {\r\n\r\n            this.codeReader.decodeFromInputVideoDevice((result: Result) => {\r\n\r\n                if (result) {\r\n                    this.dispatchScanSuccess(result);\r\n                } else {\r\n                    this.dispatchScanFailure();\r\n                }\r\n\r\n                this.dispatchScanComplete(result);\r\n\r\n            }, deviceId, this.previewElemRef.nativeElement);\r\n\r\n        } catch (err) {\r\n            this.dispatchScanError(err);\r\n            this.dispatchScanComplete(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts the scanning if allowed.\r\n     *\r\n     * @param device The device to be used in the scan.\r\n     */\r\n    startScan(device: MediaDeviceInfo): void {\r\n        if (this.scannerEnabled && device) {\r\n            this.scan(device.deviceId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops the scan service.\r\n     */\r\n    resetScan(): void {\r\n        this.codeReader.reset();\r\n    }\r\n\r\n    /**\r\n     * Stops and starts back the scan.\r\n     */\r\n    restartScan(): void {\r\n        this.resetScan();\r\n        this.startScan(this.device);\r\n    }\r\n\r\n    /**\r\n     * Dispatches the scan success event.\r\n     *\r\n     * @param result the scan result.\r\n     */\r\n    private dispatchScanSuccess(result: Result): void {\r\n        this.scanSuccess.next(result.getText());\r\n    }\r\n\r\n    /**\r\n     * Dispatches the scan failure event.\r\n     */\r\n    private dispatchScanFailure(): void {\r\n        this.scanFailure.next();\r\n    }\r\n\r\n    /**\r\n     * Dispatches the scan error event.\r\n     *\r\n     * @param err the error thing.\r\n     */\r\n    private dispatchScanError(error: any): void {\r\n        this.scanError.next(error);\r\n    }\r\n\r\n    /**\r\n     * Dispatches the scan event.\r\n     *\r\n     * @param result the scan result.\r\n     */\r\n    private dispatchScanComplete(result: Result): void {\r\n        this.scanComplete.next(result);\r\n    }\r\n\r\n    /**\r\n     * Enumerates all the available devices.\r\n     */\r\n    private async enumarateVideoDevices(): Promise<MediaDeviceInfo[]> {\r\n\r\n        if (!this.hasNavigator) {\r\n            console.error('zxing-scanner', 'enumarateVideoDevices', 'Can\\'t enumerate devices, navigator is not present.');\r\n            return;\r\n        }\r\n\r\n        if (!this.isEnumerateDevicesSuported) {\r\n            console.error('zxing-scanner', 'enumarateVideoDevices', 'Can\\'t enumerate devices, method not supported.');\r\n            return;\r\n        }\r\n\r\n        const devices = await navigator.mediaDevices.enumerateDevices();\r\n\r\n        this.videoInputDevices = [];\r\n\r\n        for (const device of devices) {\r\n\r\n            // @todo type this as `MediaDeviceInfo`\r\n            const videoDevice: any = {};\r\n\r\n            // tslint:disable-next-line:forin\r\n            for (const key in device) {\r\n                videoDevice[key] = device[key];\r\n            }\r\n\r\n            if (videoDevice.kind === 'video') {\r\n                videoDevice.kind = 'videoinput';\r\n            }\r\n\r\n            if (!videoDevice.deviceId) {\r\n                videoDevice.deviceId = (<any>videoDevice).id;\r\n            }\r\n\r\n            if (!videoDevice.label) {\r\n                videoDevice.label = 'Camera (no permission ðŸš«)';\r\n            }\r\n\r\n            if (videoDevice.kind === 'videoinput') {\r\n                this.videoInputDevices.push(videoDevice);\r\n            }\r\n        }\r\n\r\n        return this.videoInputDevices;\r\n    }\r\n}\r\n",
    "import { NgModule, ModuleWithProviders } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport { FormsModule } from '@angular/forms';\r\n\r\nimport { ZXingScannerComponent } from './zxing-scanner.component';\r\n\r\nexport type ZXingScannerComponent = ZXingScannerComponent;\r\n\r\n@NgModule({\r\n    imports: [\r\n        CommonModule,\r\n        FormsModule\r\n    ],\r\n    declarations: [ZXingScannerComponent],\r\n    exports: [ZXingScannerComponent],\r\n})\r\nexport class ZXingScannerModule {\r\n    static forRoot(): ModuleWithProviders {\r\n        return {\r\n            ngModule: ZXingScannerModule\r\n        };\r\n    }\r\n}\r\n"
  ],
  "names": [
    "extendStatics",
    "Object",
    "setPrototypeOf",
    "__proto__",
    "Array",
    "d",
    "b",
    "p",
    "hasOwnProperty",
    "__extends",
    "__",
    "this",
    "constructor",
    "prototype",
    "create",
    "__awaiter",
    "thisArg",
    "_arguments",
    "P",
    "generator",
    "Promise",
    "resolve",
    "reject",
    "fulfilled",
    "value",
    "step",
    "next",
    "e",
    "rejected",
    "result",
    "done",
    "then",
    "apply",
    "__generator",
    "body",
    "f",
    "y",
    "t",
    "g",
    "_",
    "label",
    "sent",
    "trys",
    "ops",
    "verb",
    "throw",
    "return",
    "Symbol",
    "iterator",
    "n",
    "v",
    "op",
    "TypeError",
    "call",
    "pop",
    "length",
    "push",
    "BrowserCodeReader",
    "reader",
    "timeBetweenScans",
    "torchCompatible",
    "BehaviorSubject",
    "decodeFromInputVideoDevice",
    "callbackFn",
    "deviceId",
    "videoElement",
    "reset",
    "prepareVideoElement",
    "constraints",
    "audio",
    "video",
    "facingMode",
    "exact",
    "navigator",
    "mediaDevices",
    "getUserMedia",
    "stream",
    "_a",
    "startDecodeFromStream",
    "console",
    "error",
    "err_1",
    "checkTorchCompatibility",
    "bindVideoSrc",
    "bindEvents",
    "srcObject",
    "err",
    "src",
    "window",
    "URL",
    "createObjectURL",
    "unbindVideoSrc",
    "_this",
    "videoPlayingEventListener",
    "decodingStream",
    "decodeWithDelay",
    "pipe",
    "catchError",
    "x",
    "handleDecodeStreamError",
    "subscribe",
    "addEventListener",
    "videoLoadedMetadataEventListener",
    "play",
    "track",
    "getVideoTracks",
    "ImageCapture",
    "getPhotoCapabilities",
    "capabilities",
    "compatible",
    "torch",
    "fillLightMode",
    "setTorch",
    "on",
    "applyConstraints",
    "advanced",
    "restart",
    "defineProperty",
    "get",
    "asObservable",
    "document",
    "createElement",
    "width",
    "height",
    "delay",
    "Observable",
    "observer",
    "intervalId",
    "setInterval",
    "decode",
    "clearInterval",
    "binaryBitmap",
    "createBinaryBitmap",
    "imageElement",
    "decodeBitmap",
    "caught",
    "NotFoundException",
    "ChecksumException",
    "FormatException",
    "mediaElement",
    "undefined",
    "canvasElementContext",
    "prepareCaptureCanvas",
    "drawImage",
    "luminanceSource",
    "HTMLCanvasElementLuminanceSource",
    "canvasElement",
    "hybridBinarizer",
    "HybridBinarizer",
    "BinaryBitmap",
    "videoWidth",
    "videoHeight",
    "naturalWidth",
    "naturalHeight",
    "style",
    "getContext",
    "stop",
    "unsubscribe",
    "forEach",
    "videoPlayEndedEventListener",
    "removeEventListener",
    "removeAttribute",
    "imageLoadedEventListener",
    "BrowserMultiFormatReader",
    "_super",
    "hints",
    "timeBetweenScansMillis",
    "MultiFormatReader",
    "setHints",
    "tslib_1.__extends",
    "decodeWithState",
    "BrowserQRCodeReader",
    "QRCodeReader",
    "ZXingScannerComponent",
    "_formats",
    "BarcodeFormat",
    "QR_CODE",
    "scannerEnabled",
    "autofocusEnabled",
    "previewFitMode",
    "EventEmitter",
    "scanSuccess",
    "scanFailure",
    "scanError",
    "scanComplete",
    "camerasFound",
    "camerasNotFound",
    "permissionResponse",
    "hasDevices",
    "codeReader",
    "hasNavigator",
    "isMediaDevicesSuported",
    "isEnumerateDevicesSuported",
    "enumerateDevices",
    "set",
    "hasDevice",
    "formatsInput",
    "formats",
    "map",
    "trim",
    "ngOnChanges",
    "changes",
    "videoInputDevice",
    "scan",
    "resetScan",
    "device",
    "changeDevice",
    "warn",
    "setFormats",
    "ngAfterViewInit",
    "previewElemRef",
    "nativeElement",
    "setAttribute",
    "askForPermission",
    "hasPermission",
    "enumarateVideoDevices",
    "videoInputDevices",
    "_hasDevices",
    "startScan",
    "torchAvailable",
    "emit",
    "ngOnDestroy",
    "Map",
    "restartScan",
    "changeDeviceById",
    "getDeviceById",
    "find",
    "setPermission",
    "handlePermissionException",
    "err_3",
    "permission",
    "name",
    "message",
    "dispatchScanSuccess",
    "dispatchScanFailure",
    "dispatchScanComplete",
    "dispatchScanError",
    "getText",
    "devices",
    "_b",
    "devices_1",
    "o",
    "m",
    "i",
    "tslib_1.__values",
    "devices_1_1",
    "key",
    "videoDevice",
    "kind",
    "id",
    "type",
    "Component",
    "args",
    "selector",
    "template",
    "styles",
    "changeDetection",
    "ChangeDetectionStrategy",
    "OnPush",
    "ViewChild",
    "Input",
    "Output",
    "ZXingScannerModule",
    "forRoot",
    "ngModule",
    "NgModule",
    "imports",
    "CommonModule",
    "FormsModule",
    "declarations",
    "exports"
  ],
  "mappings": "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"
}
